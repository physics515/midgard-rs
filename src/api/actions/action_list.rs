use anyhow::{bail, Result};

use crate::{APIError, ActionList, GetActionList};

/// Action List
/// List actions along with their related transactions. An action is generated by one or more inbound transactions with the intended action set in the transaction memo. The action may result in one or more outbound transactions. Results are paginated by sets of 50. Filters may be applied to query actions.
///
/// # Parameters
///
/// address: Option<Vec<String>>
/// Comma separated list. Address of sender or recipient of any in/out transaction related to the action.
///
/// txid: Option<String>
/// ID of any in/out tx related to the action
///
/// asset: Option<Vec<String>>
/// Comma separated list. Any asset that is part of the action (CHAIN.SYMBOL) Additionally, synth, nosynth, and norune filters can be used for swap, add/withdraw actions.
///
/// type: Option<Vec<String>>
///  Example: type=swap,addLiquidity
/// One or more comma separated unique types of action (swap, addLiquidity, withdraw, donate, refund, switch)
///
/// affiliate: Option<Vec<String>>
///  Examples:
/// * affiliate=thor102y0m3uptg0vvudeyh00r2fnz70wq7d8y7mu2g -
/// * affiliate=ts,thor102y0m3uptg0vvudeyh00r2fnz70wq7d8y7mu2g - Query affiliates that one is `THORName` and other is address
/// Comma separated list. Affiliate address of the action (swap, refund)
///
/// limit: Option<u64> [0..50]
/// number of actions returned, default is 50
///
/// offset: Option<u64> [0..]
/// pagination offset, default is 0
///
/// nextPageToken: Option<u64> [0..]
/// if this is given, the actions for the next page will be given
///
/// timestamp: Option<u64> [0..]
/// if this is given, the actions older than the timestamp will be given
///
/// height: Option<u64> [0..]
/// if this is given, the actions older than the height will be given
///
/// prevPageToken: Option<u64> [0..]
/// if this is given, the actions for the previous page will be given
///
/// fromTimestamp: Option<u64> [0..]
/// if this is given, the actions newer than the timestamp will be given
///
/// fromHeight: Option<u64> [0..]
/// if this is given, the actions newer than the height will be given
///
///
/// # Errors
/// 1. Network Request Failed
/// 2. JSON Parsing Error
/// 3. Faild to Parse URL Parameters
#[allow(clippy::module_name_repetitions)]
pub async fn api_get_action_list(base_url: &str, parameters: GetActionList) -> Result<ActionList> {
	let mut params = vec![];

	params.push(("asset", parameters.asset.join(",")));
	params.push(("limit", parameters.limit.to_string()));

	if let Some(address) = parameters.address {
		params.push(("address", address.join(",")));
	}
	if let Some(txid) = parameters.txid {
		params.push(("txid", txid));
	}
	if let Some(action_type) = parameters.action_type {
		params.push(("type", action_type.join(",")));
	}
	if let Some(affiliate) = parameters.affiliate {
		params.push(("affiliate", affiliate.join(",")));
	}
	if let Some(offset) = parameters.offset {
		params.push(("offset", offset.to_string()));
	}
	if let Some(next_page_token) = parameters.next_page_token {
		params.push(("nextPageToken", next_page_token.to_string()));
	}
	if let Some(timestamp) = parameters.timestamp {
		params.push(("timestamp", timestamp.to_string()));
	}
	if let Some(height) = parameters.height {
		params.push(("height", height.to_string()));
	}
	if let Some(prev_page_token) = parameters.prev_page_token {
		params.push(("prevPageToken", prev_page_token.to_string()));
	}
	if let Some(from_timestamp) = parameters.from_timestamp {
		params.push(("fromTimestamp", from_timestamp.to_string()));
	}
	if let Some(from_height) = parameters.from_height {
		params.push(("fromHeight", from_height.to_string()));
	}

	let mut endpoint = base_url.to_string() + "actions";
	if !params.is_empty() {
		endpoint.push('?');
		endpoint.push_str(&serde_urlencoded::to_string(params)?);
	}

	let response = match reqwest::get(&endpoint).await {
		Ok(response) => response,
		Err(e) => bail!(APIError::ReqwestError(e)),
	};

	let response = match response.text().await {
		Ok(response) => response,
		Err(e) => bail!(APIError::ReqwestError(e)),
	};

	println!("response: {}", response);

	let res: ActionList = match serde_json::from_str(&response) {
		Ok(res) => res,
		Err(e) => bail!(APIError::SerdeError(e)),
	};

	Ok(res)
}
